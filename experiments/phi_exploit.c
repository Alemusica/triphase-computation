/*
 * Phit Exploitation Test — Maximizing Phits (Phase-Bits)
 * =======================================================
 *
 * Obiettivo: estrarre il massimo numero di phits (phase-bits)
 * dal rapporto tra clock CPU e timer, e usarli per calcolo reale.
 *
 * Nomenclatura:
 *   phit  = singolare, 1 phase-bit (unità di informazione di fase)
 *   phits = plurale, N phase-bits
 *
 * Strategia:
 *   Il timer a 24 MHz è troppo lento per vedere singole istruzioni.
 *   Ma clock_gettime_nsec_np() dà risoluzione in ns.
 *   E soprattutto: ACCUMULANDO i delta nel tempo, il pattern
 *   di distribuzione rivela la fase CPU/timer.
 *
 *   Il trucco è usare workload calibrati dove il jitter
 *   dipende dalla fase relativa CPU↔timer.
 *
 * Compila: gcc -O0 -o phi_exploit phi_exploit.c -lm
 * Esegui:  ./phi_exploit
 *
 * Author: Alessio Cazzaniga
 */

#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include <time.h>
#include <mach/mach_time.h>

static mach_timebase_info_data_t tbi;
static volatile uint64_t sink;

/* ========== Timer ========== */

static inline uint64_t now_ns(void) {
    return clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
}

static inline uint64_t now_mach(void) {
    return mach_absolute_time();
}

/* ========== Calibrated workload ========== */
/* Tuned to take ~200-500 ns so we get 5-12 distinguishable ns values */

static void workload_calibrated(void) {
    volatile uint64_t x = 0xCAFEBABE;
    for (int i = 0; i < 20; i++) {
        x = x * 6364136223846793005ULL + 1442695040888963407ULL;
        x ^= x >> 17;
    }
    sink = x;
}

/* ========== Phi Accumulator ========== */
/*
 * Instead of reading phase once, we accumulate N readings.
 * The accumulated value encodes the path through phase space,
 * not just a single point. This gives us more phits.
 *
 * phi_accumulated = Σ (delta_i mod M) for i in 1..N
 *
 * With N accumulations and M possible values per read,
 * theoretical phits = log2(M^N) = N * log2(M)
 * Practical phits = entropy of the accumulated distribution
 */

typedef struct {
    uint64_t accumulated;
    int readings;
    int distinct_values;
} phi_state_t;

static phi_state_t phi_read_accumulated(int num_reads) {
    phi_state_t state = {0, num_reads, 0};

    for (int i = 0; i < num_reads; i++) {
        uint64_t t1 = now_ns();
        workload_calibrated();
        uint64_t t2 = now_ns();
        uint64_t delta = t2 - t1;

        /* Accumulate: each delta contributes to the phase state */
        state.accumulated += delta;
        state.accumulated ^= (state.accumulated << 3);
    }

    return state;
}

/* ========== TEST 1: Raw phi capacity ========== */

static void test_raw_phi_capacity(void) {
    printf("\n=== TEST 1: Raw Phi Capacity ===\n");
    printf("  How many distinguishable phase states per reading?\n\n");

    int n = 100000;
    uint64_t *deltas_ns = malloc(n * sizeof(uint64_t));

    /* Measure with clock_gettime_nsec_np */
    for (int i = 0; i < n; i++) {
        uint64_t t1 = now_ns();
        workload_calibrated();
        uint64_t t2 = now_ns();
        deltas_ns[i] = t2 - t1;
    }

    /* Count unique values */
    /* Simple: use a histogram up to reasonable range */
    int hist_size = 10000;
    int *hist = calloc(hist_size, sizeof(int));
    int overflow = 0;

    for (int i = 0; i < n; i++) {
        if (deltas_ns[i] < (uint64_t)hist_size) {
            hist[deltas_ns[i]]++;
        } else {
            overflow++;
        }
    }

    int unique = 0;
    double entropy = 0;
    for (int v = 0; v < hist_size; v++) {
        if (hist[v] > 0) {
            unique++;
            double p = (double)hist[v] / n;
            entropy -= p * log2(p);
        }
    }

    printf("  Samples:              %d\n", n);
    printf("  Unique delta values:  %d\n", unique);
    printf("  Shannon entropy:      %.2f bits\n", entropy);
    printf("  Theoretical max:      %.2f bits (log2(%d))\n",
           log2(unique), unique);
    printf("  Overflow (>%d ns):    %d\n", hist_size, overflow);
    printf("\n");

    /* Show distribution */
    printf("  Top 15 most common delta values (ns):\n");
    printf("  %6s | %7s | %6s | Distribution\n", "ns", "Count", "%");
    printf("  %6s-+-%7s-+-%6s-+-%s\n", "------", "-------", "------", "----------");

    for (int rank = 0; rank < 15; rank++) {
        int best_v = -1, best_c = 0;
        for (int v = 0; v < hist_size; v++) {
            if (hist[v] > best_c) {
                best_c = hist[v];
                best_v = v;
            }
        }
        if (best_c == 0) break;

        int bar_len = best_c * 30 / n;
        if (bar_len > 30) bar_len = 30;
        char bar[31];
        memset(bar, '#', bar_len);
        bar[bar_len] = '\0';

        printf("  %6d | %7d | %5.1f%% | %s\n",
               best_v, best_c, 100.0 * best_c / n, bar);
        hist[best_v] = 0;
    }

    /* Phis per reading */
    printf("\n  → PHIS PER READING: %.2f phase-bits\n", entropy);

    free(deltas_ns);
    free(hist);
}

/* ========== TEST 2: Accumulated phi scaling ========== */

static void test_accumulated_phi(void) {
    printf("\n=== TEST 2: Accumulated Phi Scaling ===\n");
    printf("  Phis grow with accumulation depth.\n\n");

    int depths[] = {1, 2, 4, 8, 16, 32, 64};
    int nd = sizeof(depths) / sizeof(depths[0]);
    int n = 50000;

    printf("  %6s | %8s | %12s | %8s | Gain\n",
           "Depth", "Unique", "Entropy", "Phis/op");
    printf("  %6s-+-%8s-+-%12s-+-%8s-+-%s\n",
           "------", "--------", "------------", "--------", "----");

    for (int di = 0; di < nd; di++) {
        int depth = depths[di];
        int hist_size = 65536;
        int *hist = calloc(hist_size, sizeof(int));

        for (int i = 0; i < n; i++) {
            phi_state_t phi = phi_read_accumulated(depth);
            hist[phi.accumulated % hist_size]++;
        }

        int unique = 0;
        double entropy = 0;
        for (int v = 0; v < hist_size; v++) {
            if (hist[v] > 0) {
                unique++;
                double p = (double)hist[v] / n;
                entropy -= p * log2(p);
            }
        }

        printf("  %6d | %8d | %12.2f | %8.2f | %.1fx\n",
               depth, unique, entropy, entropy / depth,
               (di > 0) ? entropy / (depths[0] > 0 ? entropy : 1.0) : 1.0);

        free(hist);
    }
}

/* ========== TEST 3: Phi-addressed computation ========== */

static void test_phi_computation(void) {
    printf("\n=== TEST 3: Phi-Addressed Computation ===\n");
    printf("  Use phase-bits to address different computations.\n\n");

    int n = 100000;
    int num_channels = 8;
    int64_t channels[8] = {0};
    int channel_hits[8] = {0};
    char *op_names[] = {"+1", "+2", "+3", "*2", "-1", "+5", "^7", "+10"};

    for (int i = 0; i < n; i++) {
        uint64_t t1 = now_ns();
        workload_calibrated();
        uint64_t t2 = now_ns();
        uint64_t delta = t2 - t1;

        /* Use the ns-level jitter to select a computation channel.
         * We need at least 3 bits (8 channels) from the delta.
         * Strategy: use the last 3 meaningful bits of delta.
         * Since most deltas are in a range, we XOR-fold for better distribution.
         */
        uint64_t phi = delta;
        phi ^= (phi >> 4);
        phi ^= (phi >> 2);
        int ch = phi % num_channels;

        channel_hits[ch]++;

        /* Each channel does a different operation on its accumulator */
        switch (ch) {
            case 0: channels[0] += 1; break;
            case 1: channels[1] += 2; break;
            case 2: channels[2] += 3; break;
            case 3: channels[3] = channels[3] * 2 + 1; break;
            case 4: channels[4] -= 1; break;
            case 5: channels[5] += 5; break;
            case 6: channels[6] ^= 0x7F; break;
            case 7: channels[7] += 10; break;
        }
    }

    printf("  %d operations routed to %d channels by phase.\n\n", n, num_channels);
    printf("  Ch | Op   | Hits   |   %%   | Accumulator    | Uniformity\n");
    printf("  ---+------+--------+-------+----------------+-----------\n");

    double expected = (double)n / num_channels;
    double chi2 = 0;

    for (int c = 0; c < num_channels; c++) {
        double pct = 100.0 * channel_hits[c] / n;
        double d = channel_hits[c] - expected;
        chi2 += d * d / expected;

        printf("  %2d | %-4s | %6d | %4.1f%% | %14lld | %s\n",
               c, op_names[c], channel_hits[c], pct,
               (long long)channels[c],
               fabs(pct - 100.0/num_channels) < 3.0 ? "OK" : "BIASED");
    }

    printf("\n  Chi²: %.1f (uniform if < 14.07 at p=0.05, df=7)\n", chi2);
    printf("  → %d independent computations from 1 sequential stream\n", num_channels);
    printf("  → %.1f phits used per routing decision\n", log2(num_channels));
}

/* ========== TEST 4: Phi density — how many phits can we pack? ========== */

static void test_phi_density(void) {
    printf("\n=== TEST 4: Maximum Phi Density ===\n");
    printf("  What's the maximum usable phits per unit time?\n\n");

    /* Measure how fast we can read phits */
    int n = 100000;
    uint64_t start = now_ns();
    uint64_t phi_sum = 0;

    for (int i = 0; i < n; i++) {
        uint64_t t1 = now_ns();
        workload_calibrated();
        uint64_t t2 = now_ns();
        phi_sum += (t2 - t1);
    }

    uint64_t elapsed = now_ns() - start;
    double elapsed_ms = elapsed / 1e6;
    double reads_per_sec = n / (elapsed_ms / 1000.0);

    /* With entropy from test 1 */
    /* Re-measure entropy quickly */
    int hist_size = 10000;
    int *hist = calloc(hist_size, sizeof(int));
    for (int i = 0; i < n; i++) {
        uint64_t t1 = now_ns();
        workload_calibrated();
        uint64_t t2 = now_ns();
        uint64_t d = t2 - t1;
        if (d < (uint64_t)hist_size) hist[d]++;
    }
    double entropy = 0;
    for (int v = 0; v < hist_size; v++) {
        if (hist[v] > 0) {
            double p = (double)hist[v] / n;
            entropy -= p * log2(p);
        }
    }
    free(hist);

    double phits_per_sec = reads_per_sec * entropy;

    printf("  Elapsed:             %.1f ms for %d reads\n", elapsed_ms, n);
    printf("  Reads/sec:           %.0f\n", reads_per_sec);
    printf("  Entropy/read:        %.2f phits\n", entropy);
    printf("  ─────────────────────────────────────\n");
    printf("  PHIS PER SECOND:     %.0f phit/s\n", phits_per_sec);
    printf("  PHIS PER SECOND:     %.2f Mphit/s\n", phits_per_sec / 1e6);
    printf("\n");

    /* Compare to conventional bits */
    printf("  Context: M1 Max at 3.228 GHz processes ~3.2 Gbits/s\n");
    printf("  Phase channel adds:  %.2f Mphit/s (%.4f%% extra)\n",
           phits_per_sec / 1e6,
           100.0 * phits_per_sec / 3.228e9);
    printf("\n  → Not a replacement, but an ORTHOGONAL information channel.\n");
    printf("  → Useful for: entropy source, temporal addressing, crypto,\n");
    printf("    phase-gated scheduling, non-deterministic computation.\n");
}

/* ========== TEST 5: Phi-multiplexed register ========== */

static void test_phi_register(void) {
    printf("\n=== TEST 5: Phi-Multiplexed Register (Hardware) ===\n");
    printf("  Store K values in 1 variable, addressed by phase.\n\n");

    int K = 8;  /* phase slots */
    int64_t phi_reg[8] = {100, 200, 300, 400, 500, 600, 700, 800};
    int reads_correct = 0;
    int total_reads = 0;
    int slot_reads[8] = {0};

    int n = 100000;

    for (int i = 0; i < n; i++) {
        uint64_t t1 = now_ns();
        workload_calibrated();
        uint64_t t2 = now_ns();
        uint64_t delta = t2 - t1;

        /* Map delta to slot */
        uint64_t phi = delta;
        phi ^= (phi >> 4);
        phi ^= (phi >> 2);
        int slot = phi % K;

        /* Read value from phi-addressed slot */
        int64_t value = phi_reg[slot];
        int64_t expected = (slot + 1) * 100;

        if (value == expected) reads_correct++;
        slot_reads[slot]++;
        total_reads++;

        /* Also: write back modified value (phi-gated write) */
        phi_reg[slot] = expected + 1;  /* modify */
        phi_reg[slot] = expected;      /* restore for next iteration */
    }

    printf("  Slots: %d (%.1f phits to address)\n", K, log2(K));
    printf("  Total reads:    %d\n", total_reads);
    printf("  Correct reads:  %d (%.1f%%)\n",
           reads_correct, 100.0 * reads_correct / total_reads);
    printf("\n  Slot distribution:\n");

    for (int s = 0; s < K; s++) {
        int bar_len = slot_reads[s] * 40 / (n / K * 2);
        if (bar_len > 40) bar_len = 40;
        char bar[41];
        memset(bar, '#', bar_len);
        bar[bar_len] = '\0';

        printf("    [%d] val=%4lld  hits=%6d (%4.1f%%) %s\n",
               s, (long long)phi_reg[s], slot_reads[s],
               100.0 * slot_reads[s] / n, bar);
    }

    printf("\n  → 1 variable × %d slots = %d effective values\n", K, K);
    printf("  → Density gain: %dx (%.1f extra phits per variable)\n",
           K, log2(K));
}

/* ========== Main ========== */

int main(void) {
    mach_timebase_info(&tbi);

    printf("╔══════════════════════════════════════════════════════════╗\n");
    printf("║  TRIPHASE: Phi Exploitation Test                        ║\n");
    printf("║  Maximizing phase-bits from CPU↔Timer relationship      ║\n");
    printf("║  Apple Silicon M1 Max                                   ║\n");
    printf("╚══════════════════════════════════════════════════════════╝\n");

    test_raw_phi_capacity();
    test_accumulated_phi();
    test_phi_computation();
    test_phi_density();
    test_phi_register();

    printf("\n╔══════════════════════════════════════════════════════════╗\n");
    printf("║  RESULTS SUMMARY                                        ║\n");
    printf("╠══════════════════════════════════════════════════════════╣\n");
    printf("║  Phi = phase-bit = information from clock relationship  ║\n");
    printf("║                                                         ║\n");
    printf("║  Raw phits/read:     from Test 1                         ║\n");
    printf("║  Accumulated phits:  from Test 2 (scales with depth)     ║\n");
    printf("║  Routable channels: from Test 3 (phase→computation)     ║\n");
    printf("║  Phi throughput:    from Test 4 (Mphit/s)               ║\n");
    printf("║  Memory density:    from Test 5 (Kx gain per variable)  ║\n");
    printf("╚══════════════════════════════════════════════════════════╝\n");

    return 0;
}

Metodo e sistema per l'estrazione e l'utilizzo di bit di fase computazionali (phit) dalle relazioni tra domini di clock asincroni nei processori digitali

Title (EN): Method and System for Extracting and Utilizing Computational Phase-Bits (Phits) from Asynchronous Clock Domain Relationships in Digital Processors

CAMPO DELL'INVENZIONE / FIELD OF THE INVENTION

La presente invenzione riguarda l'architettura dei processori digitali e, più specificamente, metodi e sistemi per l'estrazione di informazione utilizzabile dalle relazioni di fase tra domini di clock asincroni presenti nei moderni processori multi-clock. L'invenzione definisce una nuova unità di informazione, il "phit" (phase-bit), e fornisce metodi per estrarre, accumulare e utilizzare i phit per la generazione di entropia, la coordinazione lock-free di task e la gestione di chiavi crittografiche temporali.

CONTESTO DELL'INVENZIONE / BACKGROUND OF THE INVENTION

Problema Tecnico / Problem Statement

I moderni processori digitali contengono molteplici domini di clock indipendenti che operano a frequenze diverse. Ad esempio, il processore Apple M1 Max contiene almeno tre domini di clock distinti:
Core ad alte prestazioni (P-core) a circa 3.228 MHz
Core ad alta efficienza (E-core) a circa 2.064 MHz
Timer di sistema a 24 MHz (ARM Generic Timer, cntvct_el0)

Questi domini di clock sono asincroni l'uno rispetto all'altro. La relazione di fase tra due clock qualsiasi cambia continuamente e deterministicamente in funzione del loro rapporto di frequenza. Questa informazione di fase è attualmente trattata come rumore — qualcosa da eliminare mediante barriere di sincronizzazione, circuiti di clock domain crossing e protezioni contro la metastabilità.

La presente invenzione riconosce che questa informazione di fase non è rumore, bensì una risorsa computazionale sfruttabile con contenuto informativo misurabile.

Stato della Tecnica / Prior Art

Jitterentropy (Kernel Linux): Il modulo jitterentropy (Stephan Muller) raccoglie il jitter temporale della CPU come sorgente di entropia per /dev/random. Esegue operazioni sulla CPU, misura le variazioni temporali e raccoglie i bit meno significativi come dati casuali. Jitterentropy tratta le variazioni temporali come rumore casuale da raccogliere, producendo circa 1 bit di entropia per misurazione (stima conservativa SP 800-90B: 1/3 di bit per misurazione). Non formalizza né sfrutta la relazione di fase strutturata tra domini di clock, né utilizza l'informazione di fase per la computazione oltre alla raccolta di entropia.

Generatori hardware di numeri casuali (RDRAND/RDSEED, ARM RNDR): Intel e ARM forniscono circuiti hardware dedicati per la generazione di numeri casuali basati sul rumore termico in circuiti auto-temporizzati. Questi richiedono area di silicio dedicata e non sono disponibili su tutti i processori, in particolare sui dispositivi embedded e IoT a basso costo.

Clock Computing Machines (US10498528B2, Kwok, 2019): Questo brevetto descrive la computazione mediante stati temporali all'interno di un singolo contatore ciclico (clock machine) con N stati temporali discreti. Le clock machine utilizzano aritmetica modulare deterministica su sequenze temporali a singolo clock. La presente invenzione differisce fondamentalmente in quanto sfrutta la relazione di fase tra molteplici domini di clock asincroni con valori di fase continui (non discreti), e fornisce tre paradigmi computazionali distinti (gated, weighted, encoded) non descritti nelle clock machine.

Interfaccia sorgente di entropia RISC-V (Neumann et al., 2022): L'ISA RISC-V definisce un'estensione per sorgente di entropia che utilizza due segnali di clock sintetizzati con rapporto razionale per l'estrazione di rumore, conforme a SP 800-90B e FIPS 140-3. Questa interfaccia fornisce entropia solo per la generazione di numeri casuali. L'istruzione RDPHI proposta dalla presente invenzione restituisce informazione di fase per la computazione general-purpose (gating, weighting, encoding), non esclusivamente per l'estrazione di entropia.

TRNG a oscillatore ad anello: Generatori di numeri casuali veri basati sul jitter di fase tra oscillatori ad anello in FPGA/ASIC. Si tratta di implementazioni esclusivamente hardware che richiedono circuiti dedicati e si concentrano sull'ampiezza del jitter piuttosto che sulle relazioni di fase strutturate tra domini di clock indipendenti.

Scheduling Round-Robin e a stato condiviso: Lo scheduling convenzionale dei task nei sistemi multiprocessore si basa su contatori condivisi, operazioni atomiche o stato protetto da mutex per distribuire il lavoro tra i worker. Questi meccanismi creano punti di contesa che limitano la scalabilità.

Carenze della Tecnica Nota / Deficiencies of Prior Art

1. Nessuna arte nota formalizza la relazione di fase tra domini di clock asincroni come risorsa computazionale generale con tre paradigmi (gated, weighted, encoded).
2. Jitterentropy estrae circa 1 bit per misurazione; la presente invenzione estrae 2-4 phit per misurazione attraverso il campionamento composto.
3. Le Clock Machine (US10498528B2) utilizzano un singolo clock con stati temporali discreti; la presente invenzione utilizza molteplici clock asincroni con relazioni di fase continue.
4. I generatori hardware richiedono silicio dedicato; la presente invenzione utilizza l'infrastruttura di clock esistente su processori commerciali.
5. Lo scheduling lock-free mediante fase senza alcuno stato condiviso non è stato precedentemente proposto.
6. La sorgente di entropia RISC-V restituisce solo entropia; l'istruzione RDPHI della presente invenzione restituisce fase per la computazione.

SOMMARIO DELL'INVENZIONE / SUMMARY OF THE INVENTION

La presente invenzione introduce un framework computazionale denominato "Triphase Computation" che tratta la relazione di fase tra domini di clock asincroni come una risorsa informativa sfruttabile. Il framework definisce:

1. Il phit (phase-bit): un'unità di informazione estratta dalla relazione di fase tra due o più domini di clock asincroni.

2. Uno stato computazionale esteso: Sigma(t) = (S(t), Phi(t)), dove S(t) rappresenta lo stato spaziale convenzionale (contenuto dei registri, memoria) e Phi(t) rappresenta il vettore di fase — l'insieme delle relazioni di fase tra tutte le coppie di domini di clock al tempo t.

3. Metodi per l'estrazione di phit dall'hardware del processore esistente senza modifiche, mediante campionamento composto di valori del timer e delta temporali del carico di lavoro.

4. Tre paradigmi computazionali per l'utilizzo dei phit:
Computazione Phase-Gated: esecuzione di operazioni solo quando le fasi dei clock si allineano in punti specifici
Computazione Phase-Weighted: utilizzo dei valori di fase come coefficienti aritmetici
Computazione Phase-Encoded: multiplexing di N valori in un singolo registro mediante divisione temporale basata sulla fase

5. Tre applicazioni pratiche dimostrate su hardware commerciale:
Generazione di numeri pseudo-casuali basata sulla fase, che supera quattro test statistici ispirati a NIST SP 800-22 (Monobit, Runs, Byte Distribution, Per-Bit Entropy)
Scheduling lock-free di task utilizzando la fase invece di contatori condivisi
Cifratura phase-gated in cui la chiave crittografica è derivata dalle relazioni tra le frequenze di clock in uno specifico istante temporale

6. Un'estensione ISA proposta (istruzione RDPHI) per la lettura hardware diretta della fase, con un miglioramento del throughput proiettato di 100-300x rispetto al metodo di estrazione software.

DESCRIZIONE DETTAGLIATA DELL'INVENZIONE / DETAILED DESCRIPTION OF THE INVENTION

1. Fondamenti Teorici

1.1 Modello di Stato Esteso

Lo stato di un processore convenzionale al tempo t è descritto dal suo stato spaziale S(t) — il contenuto di registri, memoria e flag. La presente invenzione estende questo modello:

Sigma(t) = (S(t), Phi(t))

dove Phi(t) è il vettore di fase:

Phi(t) = (phi_1(t), phi_2(t), ..., phi_K(t))

Per K domini di clock con frequenze f_1, f_2, ..., f_K, ciascuna componente di fase è:

phi_i(t) = f_i * t mod 1

La differenza di fase tra due domini di clock qualsiasi i e j è:

delta_phi_ij(t) = (f_i - f_j) * t mod 1

Questa differenza di fase oscilla alla frequenza di battimento |f_i - f_j| ed è deterministica per frequenze e tempo noti, ma appare casuale a un osservatore che non conosce le frequenze esatte e il momento di osservazione.

1.2 Contenuto Informativo

L'entropia di Shannon del canale di fase tra due clock asincroni dipende dalla risoluzione di misurazione. Con un timer di risoluzione R e un carico di lavoro di durata D tick, il numero di stati di fase distinguibili è approssimativamente D/R, con:

H = log2(D/R) bit per misurazione

Per l'Apple M1 Max con timer a 24 MHz (R = 41,67 ns) e un carico di lavoro calibrato di circa 800 ns di durata, l'entropia misurata è di circa 1,96 phit per singola lettura e 4,06 phit per lettura composta (N=2).

Fondamento matematico: Quando le frequenze dei clock sono incommensurabili (il loro rapporto è irrazionale), il Teorema di Equidistribuzione di Weyl garantisce che i campioni di fase siano equidistribuiti sull'intervallo unitario. Il Teorema delle Tre Distanze (Steinhaus) vincola la struttura di campionamento a un massimo di 3 dimensioni di gap distinte. L'entropia di Kolmogorov-Sinai della rotazione deterministica è zero; l'entropia estraibile proviene dal jitter hardware nell'esecuzione del carico di lavoro, amplificato dalla struttura di fase.

1.3 L'Architettura a Triade

L'unità fondamentale della computazione trifase è una triade di tre clock asincroni:
Clock Alpha: il primo oscillatore (es. clock P-core)
Clock Beta: il secondo oscillatore (es. clock E-core)
Clock Observer: il terzo clock che campiona la relazione di fase tra Alpha e Beta (es. timer di sistema)

Due clock generano un segnale di battimento; il terzo osserva e computa sulla base della relazione di fase. Questa asimmetria è fondamentale: né Alpha né Beta possono osservare la propria relazione di fase — solo l'Observer può farlo.

2. Metodo di Estrazione dei Phit (Software)

2.1 Campionamento Base dei Phit

Il metodo per l'estrazione di un singolo campione phit dall'hardware esistente comprende:

Passo 1: Esecuzione di un carico di lavoro computazionale calibrato. Il carico di lavoro deve avere un tempo di esecuzione che varia con la relazione di fase tra il clock della CPU e il clock del timer. Una realizzazione preferita utilizza un ciclo basato su generatore lineare congruenziale (LCG) con qualificatore volatile per impedire l'ottimizzazione del compilatore e N_ITERATIONS scelto per produrre una durata del carico di lavoro di circa 200-800 nanosecondi.

Passo 2: Lettura del timer di sistema immediatamente dopo il completamento del carico di lavoro.

Passo 3: Combinazione dei bit meno significativi del timer (che sono uniformi in modo dimostrabile con Chi-quadro = 0,39) con l'informazione temporale dipendente dal carico di lavoro. I due bit meno significativi del timer forniscono entropia uniforme. I bit superiori, combinati con XOR con il risultato del carico di lavoro, catturano la variazione temporale dipendente dalla fase.

Passo 4: Applicazione di una funzione hash per distribuire il valore combinato sull'intero intervallo di output.

2.2 Campionamento Composto dei Phit

Per aumentare il numero di phit per campione, il metodo impiega il campionamento composto con N letture sequenziali:

Passo 1: Per ciascuna lettura i = 0 a N-1: variare il seed del carico di lavoro utilizzando l'indice di lettura, eseguire il carico di lavoro calibrato, leggere il timer, combinare i LSB del timer con il risultato del carico di lavoro e accumulare in una chiave composta mediante rotazione e XOR.

Passo 2: Applicazione di un hash finale alla chiave composta.

Il metodo composto con N=2 letture produce circa 4,06 phit, rispetto a 1,96 phit per una singola lettura. Il valore ottimale di N=2 fornisce il miglior compromesso tra resa in phit e throughput.

2.3 Uniformità dei Bit Meno Significativi del Timer

Una scoperta chiave di questa invenzione è che i bit meno significativi del timer di sistema presentano una distribuzione dimostrabilmente uniforme. Sull'Apple M1 Max, i 2 LSB di clock_gettime_nsec_np(CLOCK_UPTIME_RAW) producono un valore Chi-quadro di 0,39 su 4 bin (valore critico 7,81 a p=0,05, 3 gradi di libertà), confermando l'uniformità. Questa uniformità deriva dalla relazione asincrona tra il dominio di clock del timer e il dominio di clock della CPU.

2.4 Non-Stazionarietà e Robustezza

Durante lo sviluppo, è stato scoperto che la distribuzione dei delta temporali è non-stazionaria a causa dello scaling dinamico della frequenza della CPU. Il metodo di campionamento composto descritto nella Sezione 2.2 è robusto rispetto a questa non-stazionarietà perché combina LSB del timer uniformi (che sono indipendenti dalla frequenza) con il delta temporale. Ciò è stato validato empiricamente: il metodo di routing basato su CDF calibrato a una frequenza produce risultati distorti quando la frequenza cambia, mentre il campionamento composto mantiene l'uniformità.

3. Pool di Entropia dei Phit e PRNG

3.1 Struttura del Pool di Entropia

L'invenzione include un pool di accumulo dell'entropia costituito da uno stato a 256 bit suddiviso in 4 corsie da 64 bit ciascuna, un contatore di mix monotono e uno stimatore dei bit raccolti.

3.2 Alimentazione del Pool

Quando un campione phit viene immesso nel pool: (1) il contatore di mix si incrementa; (2) il campione viene combinato con il contatore utilizzando la costante del rapporto aureo per prevenire cicli; (3) il valore combinato subisce il mixing SplitMix64; (4) il risultato viene combinato con XOR nella corsia corrente del pool; (5) le corsie adiacenti vengono mixate incrociandole mediante rotazione a 64 bit di 17 posizioni.

3.3 Estrazione dal Pool

Per estrarre un valore casuale a 64 bit: (1) vengono eseguiti quattro raccolti phit freschi; (2) tutte e quattro le corsie del pool vengono combinate mediante XOR con differenti quantità di rotazione; (3) la forward security è mantenuta mutando due corsie del pool con versioni ruotate dell'output.

3.4 Risultati di Qualità del PRNG

Sull'Apple M1 Max, il PRNG supera quattro test statistici ispirati a NIST SP 800-22:

Test: Monobit — Risultato: SUPERATO — Metrica: Z-score < 3,29
Test: Runs — Risultato: SUPERATO — Metrica: Z-score < 3,29
Test: Distribuzione Byte — Risultato: SUPERATO — Metrica: Chi-quadro = 221,7 (< valore critico 310)
Test: Entropia Per-Bit — Risultato: SUPERATO — Metrica: 64,0/64,0 bit (100%)
Test: Throughput — Risultato: 181 Mbit/s — Metrica: (22,6 MB/s)
4. Routing Lock-Free di Task mediante Phit

4.1 Metodo

L'invenzione fornisce un metodo per la distribuzione di task ai thread worker senza stato condiviso:
(1) Quando un task arriva per il dispatch, si estrae un campione phit mediante campionamento composto (N=2).
(2) Si calcola: worker_id = campione_phit modulo numero_worker.
(3) Si instrada il task al worker selezionato.

Non è richiesto alcun mutex, contatore atomico o memoria condivisa. Ogni thread calcola indipendentemente la funzione di routing, e la relazione di fase tra i rispettivi clock garantisce una distribuzione uniforme.

4.2 Risultati

Sull'Apple M1 Max con 8 worker e 100.000 task:

Metrica: Chi-quadro — Valore: 7,8 (soglia di uniformità: 14,07)
Metrica: Throughput di routing — Valore: 28 Mroute/s
Metrica: Sbilanciamento massimo del carico — Valore: 2,5%
Metrica: Stato condiviso richiesto — Valore: Nessuno
Metrica: Contesa per lock — Valore: Zero
5. Cifratura Phase-Gated

5.1 Concetto

L'invenzione fornisce un metodo di cifratura in cui la chiave è derivata dalle frequenze di tre o più domini di clock (note alle parti autorizzate) e dal momento esatto della cifratura. Il keystream per la posizione del byte i al tempo t è derivato dal vettore di fase al tempo t. Cifratura e decifratura sono simmetriche (XOR con keystream).

5.2 Sensibilità Temporale

Un errore temporale di 1 microsecondo produce un output completamente diverso. Questa proprietà deriva dal fatto che le frequenze di clock (nell'ordine dei GHz) causano cambiamenti completi dei vettori di fase nell'arco di nanosecondi.

5.3 Finestre di Accesso Phase-Locked

L'invenzione fornisce inoltre un metodo per limitare la decifratura a specifiche finestre di fase — intervalli temporali in cui la fase relativa tra due domini di clock rientra in un intervallo predeterminato.

6. Estensione ISA Proposta (RDPHI)

6.1 Definizione delle Istruzioni

L'invenzione propone tre nuove istruzioni per il processore nello spazio delle estensioni custom dell'ISA RISC-V:

RDPHI rd, rs1, rs2 — Lettura della fase tra i domini di clock rs1 e rs2 nel registro rd
PHIGATE rd, rs1 — Gating dell'esecuzione sulla condizione di fase in rs1
PHIWEIGHT rd, rs1 — Restituzione della fase come peso aritmetico a virgola fissa in rd

6.2 Implementazione Hardware

L'istruzione RDPHI è implementata mediante un circuito comparatore di fase: un flip-flop campiona il contatore del dominio di clock A sul fronte di salita del dominio di clock B. Il valore campionato rappresenta la relazione di fase istantanea. Il circuito richiede circa 200 porte logiche.

6.3 Prestazioni Proiettate

Metrica: Tempo per lettura — Software (attuale): ~100 ns — Hardware (RDPHI): ~0,3 ns (1 ciclo) — Miglioramento: ~300x
Metrica: Phit per lettura — Software (attuale): ~2 — Hardware (RDPHI): ~8-16 — Miglioramento: ~4-8x
Metrica: Throughput — Software (attuale): 24,6 Mphit/s — Hardware (RDPHI): ~3-10 Gphit/s — Miglioramento: ~100-400x
Metrica: Overhead CPU — Software (attuale): Carico di lavoro + lettura timer — Hardware (RDPHI): 1 istruzione — Miglioramento: ~100x
7. Libreria Software Portabile (libphit.h)

L'invenzione include una libreria C header-only (366 righe, licenza MIT) che fornisce estrazione di phit portabile su più piattaforme:
macOS (ARM64): utilizza clock_gettime_nsec_np(CLOCK_UPTIME_RAW)
macOS (x86): utilizza clock_gettime_nsec_np(CLOCK_UPTIME_RAW)
Linux (ARM64/x86): utilizza clock_gettime(CLOCK_MONOTONIC_RAW)
FreeBSD: utilizza clock_gettime(CLOCK_MONOTONIC)

La libreria fornisce funzionalità di auto-test che validano il determinismo dell'hash, la qualità dell'output del PRNG (test monobit), l'uniformità del routing e l'avanzamento del timer.

VALIDAZIONE SPERIMENTALE / EXPERIMENTAL VALIDATION

Studio 1: Estrazione di Phit su Apple M1 Max

Cinque programmi sperimentali (phase_extract.c, phase_extract_v2.c, phi_exploit.c, phi_uniform.c, phi_adaptive.c) sono stati sviluppati per caratterizzare l'estrazione di phit sull'Apple M1 Max (CPU 10 core, GPU 32 core, 64 GB di memoria unificata). Risultati principali:

1. I LSB del timer (2 bit) sono uniformi in modo dimostrabile: Chi-quadro = 0,39 (critico: 7,81)
2. Capacità phit grezza: 1,96 phit per singola lettura
3. Campionamento composto (N=2): 4,06 phit per lettura
4. Throughput: 24,6 Mphit/s
5. Non-stazionarietà scoperta e risolta mediante campionamento composto

Studio 2: Qualità del PRNG

Il PRNG basato su phit è stato testato con quattro test statistici ispirati a NIST SP 800-22 (Monobit, Runs, Byte Distribution, Per-Bit Entropy) su 10 milioni di campioni a 64 bit. Tutti e quattro i test sono stati superati, con entropia per-bit misurata al 100% (64,0/64,0 bit).

Studio 3: Scheduler Lock-Free

100.000 task instradati a 8 worker senza stato condiviso. Uniformità Chi-quadro: 7,8 (soglia 14,07). Sbilanciamento massimo del carico: 2,5%. Zero contesa per lock. Throughput: 28 Mroute/s.

APPLICABILITÀ INDUSTRIALE / INDUSTRIAL APPLICABILITY

L'invenzione ha immediata applicabilità industriale in:

1. Sistemi embedded e dispositivi IoT privi di generatori hardware di numeri casuali, dove il metodo software di estrazione dei phit fornisce entropia di alta qualità dai clock esistenti.
2. Calcolo ad alte prestazioni, dove il routing lock-free di task mediante fase elimina la contesa nei carichi di lavoro paralleli.
3. Elaborazione audio digitale, dove la modulazione phase-weighted dei parametri DSP fornisce decorrelazione e dithering naturali.
4. Sistemi crittografici che richiedono controlli di accesso temporalmente vincolati tramite finestre di accesso phase-locked.
5. Progettazione di processori, dove l'istruzione RDPHI proposta aggiunge capacità di computazione di fase a costo minimo di silicio (~200 porte logiche).

RIFERIMENTI ALLO STATO DELLA TECNICA / PRIOR ART REFERENCES

1. Muller, S. "CPU Time Jitter Based Non-Physical True Random Number Generator." jitterentropy-library, GitHub. BSD/GPLv2.
2. Intel Corporation. "Intel Digital Random Number Generator (DRNG) Software Implementation Guide." 2021.
3. Kwok, M. "Clock Computing Machines." US Patent US10498528B2, 2019.
4. Neumann, M. et al. "Development of the RISC-V Entropy Source Interface." Journal of Cryptographic Engineering, 2022.
5. Gaines, B.R. "Stochastic Computing Systems." Advances in Information Systems Science, Vol. 2, 1969.
6. Madhavan, A., Sherwood, T., Strukov, D. "Race Logic: A hardware acceleration for dynamic programming algorithms." ISCA 2014.
7. NIST SP 800-22. "A Statistical Test Suite for Random and Pseudorandom Number Generators for Cryptographic Applications." 2010.
8. NIST SP 800-90B. "Recommendation for the Entropy Sources Used for Random Bit Generation." 2018.

Specifica preparata per: Alessio Cazzaniga
Data di preparazione: 12 febbraio 2026